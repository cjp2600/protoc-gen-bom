// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: test.proto

package main

import (
	fmt "fmt"
	bom "github.com/cjp2600/bom"
	_ "github.com/cjp2600/protoc-gen-bom/plugin/options"
	proto "github.com/gogo/protobuf/proto"
	ptypes "github.com/golang/protobuf/ptypes"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	primitive "go.mongodb.org/mongo-driver/bson/primitive"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// create MongoDB Model from protobuf (RoleMongo)
type RoleMongo struct {
	Id   primitive.ObjectID `_id, omitempty`
	Name string
	Role []*PermissionMongo
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type RoleMongo the arg will be the target, the caller the one being converted from

// RoleMongoBeforeToMongo called before default ToMongo code
type RoleMongoWithBeforeToMongo interface {
	BeforeToMongo(*RoleMongo) error
}

// RoleMongoAfterToMongo called after default ToMongo code
type RoleMongoWithAfterToMongo interface {
	AfterToMongo(*RoleMongo) error
}

// RoleMongoBeforeToPB called before default ToPB code
type RoleMongoWithBeforeToPB interface {
	BeforeToPB(*Role) error
}

// RoleMongoAfterToPB called after default ToPB code
type RoleMongoWithAfterToPB interface {
	AfterToPB(*Role) error
}

func (e *RoleMongo) ToPB() (*Role, error) {
	var resp Role
	var err error
	if prehook, ok := interface{}(e).(RoleMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(&resp); err != nil {
			return &resp, err
		}
	}
	resp.Id = e.Id.Hex()
	resp.Name = e.Name
	// create nested pb
	var subRole []*Permission
	if e.Role != nil {
		if len(e.Role) > 0 {
			for _, b := range e.Role {
				pb, err := b.ToPB()
				if err != nil {
					continue
				}
				subRole = append(subRole, pb)
			}
		}
	}
	resp.Role = subRole
	if posthook, ok := interface{}(e).(RoleMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(&resp)
	}
	return &resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *Role) ToMongo() (*RoleMongo, error) {
	var resp RoleMongo
	if prehook, ok := interface{}(e).(RoleMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	if len(e.Id) > 0 {
		resp.Id = bom.ToObj(e.Id)
	}
	resp.Name = e.Name
	// create nested mongo
	var subRole []*PermissionMongo
	if e.Role != nil {
		if len(e.Role) > 0 {
			for _, b := range e.Role {
				pb, err := b.ToMongo()
				if err != nil {
					continue
				}
				subRole = append(subRole, pb)
			}
		}
	}
	resp.Role = subRole
	if posthook, ok := interface{}(e).(RoleMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	return &resp, nil
}

func (e *RoleMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("role")
}
func (e *RoleMongo) Insert(bom *bom.Bom) (*RoleMongo, error) {
	e.Id = primitive.NewObjectID() // create object id
	res, err := e.WithBom(bom).InsertOne(e)
	if err != nil {
		return nil, err
	}
	if insertId, ok := res.InsertedID.(primitive.ObjectID); ok {
		e.Id = insertId
	}
	return e, nil
}

// create MongoDB Model from protobuf (PermissionMongo)
type PermissionMongo struct {
	Id      primitive.ObjectID `_id, omitempty`
	Service string
	Create  bool
	Read    bool
	Update  bool
	Delete  bool
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type PermissionMongo the arg will be the target, the caller the one being converted from

// PermissionMongoBeforeToMongo called before default ToMongo code
type PermissionMongoWithBeforeToMongo interface {
	BeforeToMongo(*PermissionMongo) error
}

// PermissionMongoAfterToMongo called after default ToMongo code
type PermissionMongoWithAfterToMongo interface {
	AfterToMongo(*PermissionMongo) error
}

// PermissionMongoBeforeToPB called before default ToPB code
type PermissionMongoWithBeforeToPB interface {
	BeforeToPB(*Permission) error
}

// PermissionMongoAfterToPB called after default ToPB code
type PermissionMongoWithAfterToPB interface {
	AfterToPB(*Permission) error
}

func (e *PermissionMongo) ToPB() (*Permission, error) {
	var resp Permission
	var err error
	if prehook, ok := interface{}(e).(PermissionMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(&resp); err != nil {
			return &resp, err
		}
	}
	resp.Id = e.Id.Hex()
	resp.Service = e.Service
	resp.Create = e.Create
	resp.Read = e.Read
	resp.Update = e.Update
	resp.Delete = e.Delete
	if posthook, ok := interface{}(e).(PermissionMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(&resp)
	}
	return &resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *Permission) ToMongo() (*PermissionMongo, error) {
	var resp PermissionMongo
	if prehook, ok := interface{}(e).(PermissionMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	if len(e.Id) > 0 {
		resp.Id = bom.ToObj(e.Id)
	}
	resp.Service = e.Service
	resp.Create = e.Create
	resp.Read = e.Read
	resp.Update = e.Update
	resp.Delete = e.Delete
	if posthook, ok := interface{}(e).(PermissionMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	return &resp, nil
}

func (e *PermissionMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("permission")
}
func (e *PermissionMongo) Insert(bom *bom.Bom) (*PermissionMongo, error) {
	e.Id = primitive.NewObjectID() // create object id
	res, err := e.WithBom(bom).InsertOne(e)
	if err != nil {
		return nil, err
	}
	if insertId, ok := res.InsertedID.(primitive.ObjectID); ok {
		e.Id = insertId
	}
	return e, nil
}

// create MongoDB Model from protobuf (UserMongo)
type UserMongo struct {
	Id           primitive.ObjectID `_id, omitempty`
	Active       bool
	FirstName    string
	LastName     string
	Phone        string
	Email        string
	Role         *RoleMongo
	EmailConfirm bool
	Type         UserTypes
	Token        *TokenMongo
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Arguments    map[string]string
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type UserMongo the arg will be the target, the caller the one being converted from

// UserMongoBeforeToMongo called before default ToMongo code
type UserMongoWithBeforeToMongo interface {
	BeforeToMongo(*UserMongo) error
}

// UserMongoAfterToMongo called after default ToMongo code
type UserMongoWithAfterToMongo interface {
	AfterToMongo(*UserMongo) error
}

// UserMongoBeforeToPB called before default ToPB code
type UserMongoWithBeforeToPB interface {
	BeforeToPB(*User) error
}

// UserMongoAfterToPB called after default ToPB code
type UserMongoWithAfterToPB interface {
	AfterToPB(*User) error
}

func (e *UserMongo) ToPB() (*User, error) {
	var resp User
	var err error
	if prehook, ok := interface{}(e).(UserMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(&resp); err != nil {
			return &resp, err
		}
	}
	resp.Id = e.Id.Hex()
	resp.Active = e.Active
	resp.FirstName = e.FirstName
	resp.LastName = e.LastName
	resp.Phone = e.Phone
	resp.Email = e.Email
	// create single pb
	pbRole, _ := e.Role.ToPB()
	resp.Role = pbRole
	resp.EmailConfirm = e.EmailConfirm
	resp.Type = e.Type
	// create single pb
	pbToken, _ := e.Token.ToPB()
	resp.Token = pbToken
	ptapCreatedAt, _ := ptypes.TimestampProto(e.CreatedAt)
	resp.CreatedAt = ptapCreatedAt
	ptapUpdatedAt, _ := ptypes.TimestampProto(e.UpdatedAt)
	resp.UpdatedAt = ptapUpdatedAt
	ttArguments := make(map[string]string)
	for k, v := range e.Arguments {
		ttArguments[k] = v
	}
	resp.Arguments = ttArguments
	if posthook, ok := interface{}(e).(UserMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(&resp)
	}
	return &resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *User) ToMongo() (*UserMongo, error) {
	var resp UserMongo
	if prehook, ok := interface{}(e).(UserMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	if len(e.Id) > 0 {
		resp.Id = bom.ToObj(e.Id)
	}
	resp.Active = e.Active
	resp.FirstName = e.FirstName
	resp.LastName = e.LastName
	resp.Phone = e.Phone
	resp.Email = e.Email
	// create single mongo
	pbRole, _ := e.Role.ToMongo()
	resp.Role = pbRole
	resp.EmailConfirm = e.EmailConfirm
	resp.Type = e.Type
	// create single mongo
	pbToken, _ := e.Token.ToMongo()
	resp.Token = pbToken
	// create time object
	utCreatedAt := time.Unix(e.CreatedAt.GetSeconds(), int64(e.CreatedAt.GetNanos()))
	resp.CreatedAt = utCreatedAt
	// create time object
	utUpdatedAt := time.Unix(e.UpdatedAt.GetSeconds(), int64(e.UpdatedAt.GetNanos()))
	resp.UpdatedAt = utUpdatedAt
	ttArguments := make(map[string]string)
	for k, v := range e.Arguments {
		ttArguments[k] = v
	}
	resp.Arguments = ttArguments
	if posthook, ok := interface{}(e).(UserMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	return &resp, nil
}

func (e *UserMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("user")
}
func (e *UserMongo) Insert(bom *bom.Bom) (*UserMongo, error) {
	e.Id = primitive.NewObjectID() // create object id
	res, err := e.WithBom(bom).InsertOne(e)
	if err != nil {
		return nil, err
	}
	if insertId, ok := res.InsertedID.(primitive.ObjectID); ok {
		e.Id = insertId
	}
	return e, nil
}

// create MongoDB Model from protobuf (TokenMongo)
type TokenMongo struct {
	AccessToken  string
	RefreshToken string
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type TokenMongo the arg will be the target, the caller the one being converted from

// TokenMongoBeforeToMongo called before default ToMongo code
type TokenMongoWithBeforeToMongo interface {
	BeforeToMongo(*TokenMongo) error
}

// TokenMongoAfterToMongo called after default ToMongo code
type TokenMongoWithAfterToMongo interface {
	AfterToMongo(*TokenMongo) error
}

// TokenMongoBeforeToPB called before default ToPB code
type TokenMongoWithBeforeToPB interface {
	BeforeToPB(*Token) error
}

// TokenMongoAfterToPB called after default ToPB code
type TokenMongoWithAfterToPB interface {
	AfterToPB(*Token) error
}

func (e *TokenMongo) ToPB() (*Token, error) {
	var resp Token
	var err error
	if prehook, ok := interface{}(e).(TokenMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(&resp); err != nil {
			return &resp, err
		}
	}
	resp.AccessToken = e.AccessToken
	resp.RefreshToken = e.RefreshToken
	if posthook, ok := interface{}(e).(TokenMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(&resp)
	}
	return &resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *Token) ToMongo() (*TokenMongo, error) {
	var resp TokenMongo
	if prehook, ok := interface{}(e).(TokenMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	resp.AccessToken = e.AccessToken
	resp.RefreshToken = e.RefreshToken
	if posthook, ok := interface{}(e).(TokenMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	return &resp, nil
}

func (e *TokenMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("token")
}
func (e *TokenMongo) Insert(bom *bom.Bom) (*TokenMongo, error) {
	_, err := e.WithBom(bom).InsertOne(e)
	if err != nil {
		return nil, err
	}
	return e, nil
}

// create MongoDB Model from protobuf (ProviderUsersMongo)
type ProviderUsersMongo struct {
	ProviderId primitive.ObjectID
	UserId     primitive.ObjectID
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type ProviderUsersMongo the arg will be the target, the caller the one being converted from

// ProviderUsersMongoBeforeToMongo called before default ToMongo code
type ProviderUsersMongoWithBeforeToMongo interface {
	BeforeToMongo(*ProviderUsersMongo) error
}

// ProviderUsersMongoAfterToMongo called after default ToMongo code
type ProviderUsersMongoWithAfterToMongo interface {
	AfterToMongo(*ProviderUsersMongo) error
}

// ProviderUsersMongoBeforeToPB called before default ToPB code
type ProviderUsersMongoWithBeforeToPB interface {
	BeforeToPB(*ProviderUsers) error
}

// ProviderUsersMongoAfterToPB called after default ToPB code
type ProviderUsersMongoWithAfterToPB interface {
	AfterToPB(*ProviderUsers) error
}

func (e *ProviderUsersMongo) ToPB() (*ProviderUsers, error) {
	var resp ProviderUsers
	var err error
	if prehook, ok := interface{}(e).(ProviderUsersMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(&resp); err != nil {
			return &resp, err
		}
	}
	resp.ProviderId = e.ProviderId.Hex()
	resp.UserId = e.UserId.Hex()
	if posthook, ok := interface{}(e).(ProviderUsersMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(&resp)
	}
	return &resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *ProviderUsers) ToMongo() (*ProviderUsersMongo, error) {
	var resp ProviderUsersMongo
	if prehook, ok := interface{}(e).(ProviderUsersMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	if len(e.ProviderId) > 0 {
		resp.ProviderId = bom.ToObj(e.ProviderId)
	}
	if len(e.UserId) > 0 {
		resp.UserId = bom.ToObj(e.UserId)
	}
	if posthook, ok := interface{}(e).(ProviderUsersMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(&resp); err != nil {
			return &resp, err
		}
	}
	return &resp, nil
}

func (e *ProviderUsersMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("providerusers")
}
func (e *ProviderUsersMongo) Insert(bom *bom.Bom) (*ProviderUsersMongo, error) {
	_, err := e.WithBom(bom).InsertOne(e)
	if err != nil {
		return nil, err
	}
	return e, nil
}
