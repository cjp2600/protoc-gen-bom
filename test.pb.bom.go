// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: test.proto

package main

import (
	fmt "fmt"
	bom "github.com/cjp2600/bom"
	_ "github.com/cjp2600/protoc-gen-bom/plugin/options"
	proto "github.com/gogo/protobuf/proto"
	ptypes "github.com/golang/protobuf/ptypes"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	primitive "go.mongodb.org/mongo-driver/bson/primitive"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// create MongoDB Model from protobuf (RoleMongo)
type RoleMongo struct {
	Id   primitive.ObjectID `_id, omitempty`
	Name string
	Role []*PermissionMongo
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type RoleMongo the arg will be the target, the caller the one being converted from

// RoleMongoBeforeToMongo called before default ToMongo code
type RoleMongoWithBeforeToMongo interface {
	BeforeToMongo(*RoleMongo) error
}

// RoleMongoAfterToMongo called after default ToMongo code
type RoleMongoWithAfterToMongo interface {
	AfterToMongo(*RoleMongo) error
}

// RoleMongoBeforeToPB called before default ToPB code
type RoleMongoWithBeforeToPB interface {
	BeforeToPB(*Role) error
}

// RoleMongoAfterToPB called after default ToPB code
type RoleMongoWithAfterToPB interface {
	AfterToPB(*Role) error
}

func (e *RoleMongo) ToPB() (*Role, error) {
	var resp *Role
	var err error
	if prehook, ok := interface{}(e).(RoleMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(resp); err != nil {
			return resp, err
		}
	}
	resp.Id = e.Id.Hex()
	resp.Name = e.Name
	if posthook, ok := interface{}(e).(RoleMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(resp)
	}
	return resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *Role) ToMongo() (*RoleMongo, error) {
	var resp *RoleMongo
	if prehook, ok := interface{}(e).(RoleMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(resp); err != nil {
			return resp, err
		}
	}
	resp.Id = bom.ToObj(e.Id)
	resp.Name = e.Name
	if posthook, ok := interface{}(e).(RoleMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(resp); err != nil {
			return resp, err
		}
	}
	return resp, nil
}

func (e *RoleMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("role")
}

// create MongoDB Model from protobuf (PermissionMongo)
type PermissionMongo struct {
	Id      primitive.ObjectID `_id, omitempty`
	Service string
	Create  bool
	Read    bool
	Update  bool
	Delete  bool
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type PermissionMongo the arg will be the target, the caller the one being converted from

// PermissionMongoBeforeToMongo called before default ToMongo code
type PermissionMongoWithBeforeToMongo interface {
	BeforeToMongo(*PermissionMongo) error
}

// PermissionMongoAfterToMongo called after default ToMongo code
type PermissionMongoWithAfterToMongo interface {
	AfterToMongo(*PermissionMongo) error
}

// PermissionMongoBeforeToPB called before default ToPB code
type PermissionMongoWithBeforeToPB interface {
	BeforeToPB(*Permission) error
}

// PermissionMongoAfterToPB called after default ToPB code
type PermissionMongoWithAfterToPB interface {
	AfterToPB(*Permission) error
}

func (e *PermissionMongo) ToPB() (*Permission, error) {
	var resp *Permission
	var err error
	if prehook, ok := interface{}(e).(PermissionMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(resp); err != nil {
			return resp, err
		}
	}
	resp.Id = e.Id.Hex()
	resp.Service = e.Service
	resp.Create = e.Create
	resp.Read = e.Read
	resp.Update = e.Update
	resp.Delete = e.Delete
	if posthook, ok := interface{}(e).(PermissionMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(resp)
	}
	return resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *Permission) ToMongo() (*PermissionMongo, error) {
	var resp *PermissionMongo
	if prehook, ok := interface{}(e).(PermissionMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(resp); err != nil {
			return resp, err
		}
	}
	resp.Id = bom.ToObj(e.Id)
	resp.Service = e.Service
	resp.Create = e.Create
	resp.Read = e.Read
	resp.Update = e.Update
	resp.Delete = e.Delete
	if posthook, ok := interface{}(e).(PermissionMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(resp); err != nil {
			return resp, err
		}
	}
	return resp, nil
}

func (e *PermissionMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("permission")
}

// create MongoDB Model from protobuf (UserMongo)
type UserMongo struct {
	Id           primitive.ObjectID `_id, omitempty`
	Active       bool
	FirstName    string
	LastName     string
	Phone        string
	Email        string
	Role         *RoleMongo
	EmailConfirm bool
	Type         UserTypes
	Token        *TokenMongo
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type UserMongo the arg will be the target, the caller the one being converted from

// UserMongoBeforeToMongo called before default ToMongo code
type UserMongoWithBeforeToMongo interface {
	BeforeToMongo(*UserMongo) error
}

// UserMongoAfterToMongo called after default ToMongo code
type UserMongoWithAfterToMongo interface {
	AfterToMongo(*UserMongo) error
}

// UserMongoBeforeToPB called before default ToPB code
type UserMongoWithBeforeToPB interface {
	BeforeToPB(*User) error
}

// UserMongoAfterToPB called after default ToPB code
type UserMongoWithAfterToPB interface {
	AfterToPB(*User) error
}

func (e *UserMongo) ToPB() (*User, error) {
	var resp *User
	var err error
	if prehook, ok := interface{}(e).(UserMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(resp); err != nil {
			return resp, err
		}
	}
	resp.Id = e.Id.Hex()
	resp.Active = e.Active
	resp.FirstName = e.FirstName
	resp.LastName = e.LastName
	resp.Phone = e.Phone
	resp.Email = e.Email
	resp.EmailConfirm = e.EmailConfirm
	resp.Type = e.Type
	ptapCreatedAt, _ := ptypes.TimestampProto(e.CreatedAt)
	resp.CreatedAt = ptapCreatedAt
	ptapUpdatedAt, _ := ptypes.TimestampProto(e.UpdatedAt)
	resp.UpdatedAt = ptapUpdatedAt
	if posthook, ok := interface{}(e).(UserMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(resp)
	}
	return resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *User) ToMongo() (*UserMongo, error) {
	var resp *UserMongo
	if prehook, ok := interface{}(e).(UserMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(resp); err != nil {
			return resp, err
		}
	}
	resp.Id = bom.ToObj(e.Id)
	resp.Active = e.Active
	resp.FirstName = e.FirstName
	resp.LastName = e.LastName
	resp.Phone = e.Phone
	resp.Email = e.Email
	resp.EmailConfirm = e.EmailConfirm
	resp.Type = e.Type
	// create time object
	utCreatedAt := time.Unix(e.CreatedAt.GetSeconds(), int64(e.CreatedAt.GetNanos()))
	resp.CreatedAt = utCreatedAt
	// create time object
	utUpdatedAt := time.Unix(e.UpdatedAt.GetSeconds(), int64(e.UpdatedAt.GetNanos()))
	resp.UpdatedAt = utUpdatedAt
	if posthook, ok := interface{}(e).(UserMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(resp); err != nil {
			return resp, err
		}
	}
	return resp, nil
}

func (e *UserMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("user")
}

// create MongoDB Model from protobuf (TokenMongo)
type TokenMongo struct {
	AccessToken  string
	RefreshToken string
}

// create MongoDB Model from protobuf (ProviderUsersMongo)
type ProviderUsersMongo struct {
	ProviderId primitive.ObjectID
	UserId     primitive.ObjectID
}

// The following are interfaces you can implement for special behavior during Mongo/PB conversions
// of type ProviderUsersMongo the arg will be the target, the caller the one being converted from

// ProviderUsersMongoBeforeToMongo called before default ToMongo code
type ProviderUsersMongoWithBeforeToMongo interface {
	BeforeToMongo(*ProviderUsersMongo) error
}

// ProviderUsersMongoAfterToMongo called after default ToMongo code
type ProviderUsersMongoWithAfterToMongo interface {
	AfterToMongo(*ProviderUsersMongo) error
}

// ProviderUsersMongoBeforeToPB called before default ToPB code
type ProviderUsersMongoWithBeforeToPB interface {
	BeforeToPB(*ProviderUsers) error
}

// ProviderUsersMongoAfterToPB called after default ToPB code
type ProviderUsersMongoWithAfterToPB interface {
	AfterToPB(*ProviderUsers) error
}

func (e *ProviderUsersMongo) ToPB() (*ProviderUsers, error) {
	var resp *ProviderUsers
	var err error
	if prehook, ok := interface{}(e).(ProviderUsersMongoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(resp); err != nil {
			return resp, err
		}
	}
	resp.ProviderId = e.ProviderId.Hex()
	resp.UserId = e.UserId.Hex()
	if posthook, ok := interface{}(e).(ProviderUsersMongoWithAfterToPB); ok {
		err = posthook.AfterToPB(resp)
	}
	return resp, err
}

// ToMongo runs the BeforeToMongo hook if present, converts the fields of this
// object to Mongo format, runs the AfterToMongo hook, then returns the Mongo object
func (e *ProviderUsers) ToMongo() (*ProviderUsersMongo, error) {
	var resp *ProviderUsersMongo
	if prehook, ok := interface{}(e).(ProviderUsersMongoWithBeforeToMongo); ok {
		if err := prehook.BeforeToMongo(resp); err != nil {
			return resp, err
		}
	}
	resp.ProviderId = bom.ToObj(e.ProviderId)
	resp.UserId = bom.ToObj(e.UserId)
	if posthook, ok := interface{}(e).(ProviderUsersMongoWithAfterToMongo); ok {
		if err := posthook.AfterToMongo(resp); err != nil {
			return resp, err
		}
	}
	return resp, nil
}

func (e *ProviderUsersMongo) WithBom(b *bom.Bom) *bom.Bom {
	return b.WithColl("providerusers")
}
